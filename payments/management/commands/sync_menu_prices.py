from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from decimal import Decimal
from typing import List, Dict, Any, Optional
import importlib
import json
import os
from difflib import SequenceMatcher

from payments.models import ProductPrice
from payments.paypal_api import PayPalClient


class Command(BaseCommand):
    help = (
        "Sync prices for American menu items into ProductPrice by matching names "
        "to PayPal products (exact, then fuzzy). Default source is the in-repo script."
    )

    def add_arguments(self, parser):
        parser.add_argument(
            "--json",
            dest="json_path",
            default=None,
            help="Path to a JSON file generated by scripts/american_menu_payloads.py. If omitted, imports the script module to get items.",
        )
        parser.add_argument(
            "--override",
            action="store_true",
            help="Override existing prices instead of only creating missing ones.",
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help="Show what would change without writing to the DB.",
        )
        parser.add_argument(
            "--min-fuzzy",
            dest="min_fuzzy",
            default="0.82",
            help="Minimum fuzzy ratio (0-1) to accept a name match when no exact match is found. Default 0.82.",
        )

    def handle(self, *args, **options):
        json_path: Optional[str] = options.get("json_path")
        override: bool = options.get("override")
        dry_run: bool = options.get("dry_run")
        try:
            min_fuzzy = float(options.get("min_fuzzy"))
        except Exception:
            min_fuzzy = 0.82

        # 1) Load menu items with suggested prices
        items = self._load_menu_items(json_path)
        if not items:
            raise CommandError("No menu items loaded.")

        # 2) Fetch PayPal products
        pp = PayPalClient()
        result = pp.list_all_products()
        if not result.get("ok"):
            raise CommandError(f"Failed to fetch PayPal products: {result.get('error')}")

        products = result.get("data", {}).get("products", [])
        if not products:
            raise CommandError("No PayPal products found.")

        # Build name->list[product] map (case-insensitive)
        by_name: Dict[str, List[Dict[str, Any]]] = {}
        for p in products:
            name = (p.get("name") or "").strip()
            if not name:
                continue
            by_name.setdefault(name.lower(), []).append(p)

        created = 0
        updated = 0
        skipped = 0
        decisions: List[Dict[str, Any]] = []

        @transaction.atomic
        def upsert_prices():
            nonlocal created, updated, skipped
            for it in items:
                name = (it.get("name") or "").strip()
                price = it.get("price") or it.get("suggested_price")
                currency = (it.get("currency") or "USD").strip().upper()
                if not name or price is None:
                    skipped += 1
                    decisions.append({"item": name, "action": "skip", "reason": "missing name or price"})
                    continue

                # Try exact (case-insensitive) match first
                match: Optional[Dict[str, Any]] = None
                exact = by_name.get(name.lower())
                if exact:
                    match = exact[0]
                else:
                    # Fuzzy match by highest ratio
                    best = (0.0, None)
                    for p in products:
                        pname = (p.get("name") or "").strip()
                        if not pname:
                            continue
                        ratio = SequenceMatcher(None, pname.lower(), name.lower()).ratio()
                        if ratio > best[0]:
                            best = (ratio, p)
                    if best[0] >= min_fuzzy:
                        match = best[1]

                if not match:
                    skipped += 1
                    decisions.append({"item": name, "action": "skip", "reason": "no product match"})
                    continue

                pid = match.get("id")
                if not pid:
                    skipped += 1
                    decisions.append({"item": name, "action": "skip", "reason": "matched product missing id"})
                    continue

                # Upsert ProductPrice
                try:
                    obj, is_created = ProductPrice.objects.get_or_create(
                        product_id=pid,
                        defaults={"price": Decimal(str(price)), "currency": currency},
                    )
                    if is_created:
                        created += 1
                        decisions.append({"item": name, "action": "create", "product_id": pid, "price": str(price), "currency": currency})
                    else:
                        if override:
                            old_price = str(obj.price)
                            obj.price = Decimal(str(price))
                            obj.currency = currency
                            obj.save(update_fields=["price", "currency"])
                            updated += 1
                            decisions.append({"item": name, "action": "update", "product_id": pid, "from": old_price, "to": str(price), "currency": currency})
                        else:
                            skipped += 1
                            decisions.append({"item": name, "action": "skip", "reason": "exists"})
                except Exception as e:
                    skipped += 1
                    decisions.append({"item": name, "action": "error", "error": str(e)})

        if dry_run:
            self.stdout.write(self.style.WARNING("[dry-run] No DB changes will be made."))
        else:
            upsert_prices()

        # Always print a summary (decisions still computed via logic above)
        summary = {
            "total_items": len(items),
            "created": created,
            "updated": updated,
            "skipped": skipped,
        }
        self.stdout.write(json.dumps(summary, indent=2))

        # Print a few decision lines for transparency
        show = decisions[:20]
        if show:
            self.stdout.write(self.style.MIGRATE_HEADING("Sample decisions:"))
            for d in show:
                self.stdout.write("- " + json.dumps(d))

    def _load_menu_items(self, json_path: Optional[str]) -> List[Dict[str, Any]]:
        """Return list of dicts with keys: name, price (suggested_price), currency."""
        records: List[Dict[str, Any]] = []
        if json_path:
            if not os.path.exists(json_path):
                raise CommandError(f"JSON file not found: {json_path}")
            with open(json_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            # Expect the structure produced by american_menu_payloads.py
            for row in data.get("local_price_suggestions", []):
                records.append(
                    {
                        "name": row.get("product_name"),
                        "price": row.get("price"),
                        "currency": row.get("currency") or "USD",
                    }
                )
            return records

        # Import from the in-repo script module
        try:
            mod = importlib.import_module("scripts.american_menu_payloads")
        except Exception as e:
            raise CommandError(
                f"Failed to import scripts.american_menu_payloads: {e}. "
                f"Pass --json path to a generated JSON file instead."
            )

        if not hasattr(mod, "american_menu"):
            raise CommandError("Module missing american_menu() function.")

        items = mod.american_menu()
        for it in items:
            # Be robust to dataclass vs dict
            name = getattr(it, "name", None) or (isinstance(it, dict) and it.get("name"))
            price = getattr(it, "suggested_price", None) or (isinstance(it, dict) and it.get("suggested_price"))
            currency = getattr(it, "currency", None) or (isinstance(it, dict) and it.get("currency")) or "USD"
            records.append({"name": name, "price": price, "currency": currency})
        return records

